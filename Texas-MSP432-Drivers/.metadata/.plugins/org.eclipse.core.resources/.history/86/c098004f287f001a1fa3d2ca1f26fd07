/* DriverLib Includes */
#include <ti/devices/msp432p4xx/driverlib/driverlib.h>
//#include <driverlib.h>

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <Drivers_Control.h>
int contador = 1;

uint32_t MCLK_timer[2];
uint32_t SMCLK_timer[2];
uint32_t HSMCLK_timer[2];
uint32_t DCO_timer[2];
uint32_t ACLK_timer[2];
uint32_t BCLK_timer[2];

void T32_interrupt_rotine(void);
double dr_T32_getPeriod_seg()
{
	Timer32_clearInterruptFlag(TIMER32_0_BASE);
	double period = TIMER32_1->LOAD;
	period = period / (CS_getMCLK());
	return period;
}
void dr_T32_init(float tempo_seg)
{
	uint32_t mclk = CS_getMCLK();
	double count_period = mclk / 256;
	count_period = count_period * tempo_seg;

	Timer32_initModule(TIMER32_0_BASE, TIMER32_PRESCALER_256, TIMER32_32BIT,
	TIMER32_PERIODIC_MODE);
	Timer32_setCount(TIMER32_0_BASE, count_period);
}
void dr_T32_start()
{
	Timer32_startTimer(TIMER32_0_BASE, false);
}
void dr_T32_interrupt_init(void rotina(void))
{
	// Sempre definir uma rotina para receber a interrupção como a registrada aqui
	Interrupt_registerInterrupt(INT_T32_INT1, rotina);
	Interrupt_enableInterrupt(INT_T32_INT1);

}
void T32_2_routine(void){
	printf("\n\rEntrou na interrupcao do timer2: %d count",TIMER32_1->LOAD);
}

int main(void)
{

	WDT_A_holdTimer();
	// pegar valor dos oscliadores
	MCLK_timer[0] = CS_getMCLK();
	SMCLK_timer[0] = CS_getSMCLK();
	HSMCLK_timer[0] = CS_getHSMCLK();
	DCO_timer[0] = CS_getDCOFrequency();
	ACLK_timer[0] = CS_getACLK();
	BCLK_timer[0] = CS_getBCLK();

	// Selecionar Função dos Pinos
	dr_Pin_config_1();
	dr_Config_uart();
	printf("\r\nPrintf support for the launchpad\r\n");

	printf("Decimal(10) :%d\r\n", 10);
	printf("Hex(10)     :%x\r\n", 10);
	printf("float       :%f\r\n", 4.32);

//	dr_T32_init(0.5);
	float freq_Hz = 10;
	uint32_t mclk = CS_getMCLK();
	double count_period = mclk / freq_Hz;
// timer 32_0
	Timer32_initModule(TIMER32_0_BASE, TIMER32_PRESCALER_1, TIMER32_32BIT,
	TIMER32_PERIODIC_MODE);
	Timer32_setCount(TIMER32_0_BASE, count_period);
// timer 32_1
	double count_period2 = mclk / 10;
	Timer32_initModule(TIMER32_1_BASE, TIMER32_PRESCALER_1, TIMER32_32BIT,
						TIMER32_PERIODIC_MODE);

	Timer32_setCount(TIMER32_1_BASE, count_period2);
// *****************************************************
	Interrupt_registerInterrupt(INT_T32_INT2, T32_2_routine);
	Interrupt_enableInterrupt(INT_T32_INT2);
// *********************************************************
	dr_T32_interrupt_init(T32_interrupt_rotine);


	dr_Interrupt_uart();
	dr_Interrupt_on();
	dr_T32_start();
	Timer32_startTimer(TIMER32_1_BASE, false);
	while (1)
	{
		dr_Alterar_LEDS(contador);
		dr_delay_s(2);
	}
}

void EUSCIA0_IRQHandler(void)
{
	uint32_t status = UART_getEnabledInterruptStatus(EUSCI_A0_BASE);
	if (status & EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG)
	{
		dr_Start_tick();
		contador = UART_receiveData(EUSCI_A0_BASE) - 48;
		printf("\n\rAtualizando o valor para os Leds em: %d ->>>>>><<<<---",
				contador);
		dr_Stop_tick();
		MCLK_timer[1] = CS_getMCLK();
		SMCLK_timer[1] = CS_getSMCLK();
		HSMCLK_timer[1] = CS_getHSMCLK();
		DCO_timer[1] = CS_getDCOFrequency();
		ACLK_timer[1] = CS_getACLK();
		BCLK_timer[1] = CS_getBCLK();
		printf("\n\r[0] MCLK: %d, SMCLK:%d, HSMCLK: %d,\n\r DCO: %d, ACLK: %d, BCLK: %d",
				MCLK_timer[0], SMCLK_timer[0], HSMCLK_timer[0], DCO_timer[0],
				ACLK_timer[0], BCLK_timer[0]);
		printf("\n\r[1] MCLK: %d, SMCLK:%d, HSMCLK: %d,\n\r DCO: %d, ACLK: %d, BCLK: %d",
				MCLK_timer[1], SMCLK_timer[1], HSMCLK_timer[1], DCO_timer[1],
				ACLK_timer[1], BCLK_timer[1]);
		uint32_t estado = Timer32_getInterruptStatus(TIMER32_0_BASE);
		uint32_t timercount = Timer32_getValue(TIMER32_0_BASE);
		printf("\n\rFlag[%d], timercount:%d", estado, timercount);
	}
}
void T32_interrupt_rotine(void)
{

	printf("\n\rEntrou na interrupcao do timer1: %f seg",
			dr_T32_getPeriod_seg());
}

