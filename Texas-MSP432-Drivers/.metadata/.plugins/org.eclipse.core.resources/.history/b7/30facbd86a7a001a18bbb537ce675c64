/* DriverLib Includes */
#include <ti/devices/msp432p4xx/driverlib/driverlib.h>
//#include <driverlib.h>

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <Drivers_Control.h>
int contador = 1;

uint32_t MCLK_timer[2];
uint32_t SMCLK_timer[2];
uint32_t HSMCLK_timer[2];
uint32_t DCO_timer[2];
uint32_t ACLK_timer[2];
uint32_t BCLK_timer[2];

/* Slave Address */
#define SLAVE_ADDRESS_1     0x69

/* Statics */
//static uint8_t RXData[10];
uint32_t contador_RX = 0;
uint8_t RXData2;

/* I2C Master Configuration Parameter */
const eUSCI_I2C_MasterConfig i2cConfig = {
EUSCI_B_I2C_CLOCKSOURCE_SMCLK,          // SMCLK Clock Source
		12000000,                                // SMCLK = 12MHz
		EUSCI_B_I2C_SET_DATA_RATE_400KBPS,      // Desired I2C Clock of 400khz
		0,                                      // No byte counter threshold
		EUSCI_B_I2C_NO_AUTO_STOP                // No Autostop
		};

int main(void)
{

	WDT_A_holdTimer();
	// pegar valor dos oscliadores
	MCLK_timer[0] = CS_getMCLK();
	SMCLK_timer[0] = CS_getSMCLK();
	HSMCLK_timer[0] = CS_getHSMCLK();
	DCO_timer[0] = CS_getDCOFrequency();
	ACLK_timer[0] = CS_getACLK();
	BCLK_timer[0] = CS_getBCLK();

	dr_Pin_config_1();
	dr_Config_uart();
	printf("\r\nPrintf support for the launchpad\r\n");

	printf("Decimal(10) :%d\r\n", 10);
	printf("Hex(10)     :%x\r\n", 10);
	printf("float       :%f\r\n", 4.32);

	/* Select Port 1 for I2C - Set Pin 6, 7 to input Primary Module Function,
	 *   (UCB0SIMO/UCB0SDA, UCB0SOMI/UCB0SCL). and setting P5.5 for input mode
	 *   with pull-up enabled
	 */
	GPIO_setAsPeripheralModuleFunctionInputPin(
	GPIO_PORT_P1,
												GPIO_PIN6 + GPIO_PIN7,
												GPIO_PRIMARY_MODULE_FUNCTION);

	// Selecionar Função dos Pinos
	/* Initializing I2C Master to SMCLK at 100khz with no autostop */
	I2C_initMaster(EUSCI_B0_BASE, &i2cConfig);
	I2C_setSlaveAddress(EUSCI_B0_BASE, SLAVE_ADDRESS_1);

	/* Set in transmit mode */
	I2C_setMode(EUSCI_B0_BASE, EUSCI_B_I2C_TRANSMIT_MODE);

	/* Clearing interrupts for I2C and enabling the module */
	I2C_enableModule(EUSCI_B0_BASE);

//	Interrupt_enableInterrupt(INT_EUSCIB0);

	// enable RX interrupts
//	I2C_enableInterrupt(EUSCI_B0_BASE, EUSCI_B_I2C_RECEIVE_INTERRUPT0);

	dr_Interrupt_uart();
	dr_Interrupt_on();

	while (1)
	{
		dr_Alterar_LEDS(contador);

		uint8_t txData = 0x75;

		I2C_masterSendStart(EUSCI_B0_BASE);
		I2C_masterSendMultiByteStart(EUSCI_B0_BASE, txData);
//		I2C_masterSendMultiByteStop(EUSCI_B0_BASE);
//		if (RxData3 != 0 && contador_RX < 10)
//		{
//			RXData[contador_RX] = RxData3;
//			contador_RX++;
//		}
		dr_delay_s(2);
	}
}
void EUSCIB0_IRQHandler(void)
{
	uint_fast16_t status;

	status = I2C_getEnabledInterruptStatus(EUSCI_B0_BASE);

	/* Receives bytes into the receive buffer. If we have received all bytes,
	 * send a STOP condition */
	if (status & EUSCI_B_I2C_RECEIVE_INTERRUPT0)
	{
		// One-byte Read
		RXData2 = I2C_masterReceiveSingle(EUSCI_B0_BASE);
		if (RXData2 != 0)
			printf("-%x-", RXData2);
	}
}
void EUSCIA0_IRQHandler(void)
{
	uint32_t status = UART_getEnabledInterruptStatus(EUSCI_A0_BASE);
	if (status & EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG)
	{
		dr_Start_tick();
		contador = UART_receiveData(EUSCI_A0_BASE) - 48;
		printf("\n\n\rAtualizando o valor para os Leds em: %d ->>>>>><<<<---",
				contador);
		dr_Stop_tick();

		I2C_setMode(EUSCI_B0_BASE, EUSCI_B_I2C_RECEIVE_MODE);

		I2C_masterSendStart(EUSCI_B0_BASE);
		uint8_t RxData3 = I2C_masterReceiveSingleByte(EUSCI_B0_BASE);

		printf("\n\r[0]i2c:RXData : %d", RxData3);
		I2C_setMode(EUSCI_B0_BASE, EUSCI_B_I2C_TRANSMIT_MODE);

	}
}

